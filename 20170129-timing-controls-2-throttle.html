<!DOCTYPE html><html lang="en-US"><head><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/assets/Inter.css"/><link rel="stylesheet" href="/assets/atom-one-dark.css"/><title>Timing Controls 2 - Throttle | BLOG.MY</title><link rel="stylesheet" href="/assets/styles.css"/></head><body><nav><a href="/" class="brand_3">BLOG.MY</a><a href="/about" class="link_4">About</a><a href="/archive" class="link_4 siblingLink_5">Archive</a></nav><hr class="hidden_1"/><h1>Timing Controls 2 - Throttle</h1><main><p>Throttling is the technique of limiting events within a time duration. This is in contrast to how debounce operates. While a debounced function is called just once (either on the first or final event), a throttled function is called several times but after a certain delay. Think of it as a <em>cooldown</em> period after every event.</p>
<p>When we see the first event, call <code>fn()</code> and enter the cooldown period. Any events that occur within this time duration are lost. When timer runs out, start listening for events again.</p>
<figure><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>{
    <span class="hljs-keyword">let</span> isWaiting = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (!isWaiting) {
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            isWaiting = <span class="hljs-literal">true</span>

            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                isWaiting = <span class="hljs-literal">false</span>
            }, delay)
        }
    }
}

<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, throttle(foo, <span class="hljs-number">1000</span>))</code></pre><figcaption>Throttle events</figcaption></figure><h2 id="demo">Demo</h2>
<figure><iframe src="https://codepen.io/zhirzh/embed/VwwVyrZ?default-tab=js,result" title="Timing Controls - Throttle"></iframe><figcaption>Timing Controls - Throttle</figcaption></figure><h2 id="problems">Problems</h2>
<p>After running the demo a few time, you may have noticed 2 things about the current implementation:</p>
<ol>
<li>First event is <strong>always</strong> handled</li>
<li>final event is <strong>never</strong> handled</li>
</ol>
<p>Maybe we don&#39;t want that first event or maybe we really need that final event. Let&#39;s modify the code to address these cases.</p>
<h3 id="skip-first">Skip First</h3>
<p>To check whether we should ignore the first event or not we add new parameter <code>skipFirst</code> and to track whether the first event has fired or not we add the <code>isFirst</code> flag.</p>
<p>When first event is fired and <code>skipFirst</code> is <code>true</code> then don&#39;t call <code>fn()</code>. Also, set a timer for <code>delay</code> ms to set <code>isFirst</code> to <code>false</code>.</p>
<figure><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay, skipFirst</span>) </span>{
    <span class="hljs-keyword">let</span> isWaiting = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> isFirst = <span class="hljs-literal">true</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isFirst) {
            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                isFirst = <span class="hljs-literal">false</span>
            }, delay)
        }

        <span class="hljs-keyword">if</span> (!isWaiting &amp;&amp; !(isFirst &amp;&amp; skipFirst)) {
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            isWaiting = <span class="hljs-literal">true</span>

            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                isWaiting = <span class="hljs-literal">false</span>
            }, delay)
        }
    }
}</code></pre><figcaption>Throttle without the first event</figcaption></figure><h3 id="keep-final">Keep final</h3>
<p>Keeping track of the final event is a bit tricky. First of all, it is not possible to infer if an event is a &quot;fresh&quot; event or some previous event. And since we need to do the same actions in both cases, we extract out the common flow as the <code>work()</code> function.</p>
<p>We create the <code>final</code> variable to preserve the data for the final event. We can also use it to track when the final event is supposed to fire.</p>
<p>The idea here is to listen for events that are fired during the cooldown phase. Instead of discarding them, we set a timer for <code>delay</code> ms to handle that event unless some other event is fired after the cooldown ends and before the timer runs out.</p>
<figure><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay, keepFinal</span>) </span>{
    <span class="hljs-keyword">let</span> isWaiting = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> finalTimer

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isWaiting &amp;&amp; keepFinal) {
            clearTimeout(finalTimer)
            finalTimer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                work.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            }, delay)
        }

        <span class="hljs-keyword">if</span> (!isWaiting) {
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            isWaiting = <span class="hljs-literal">true</span>

            clearTimeout(finalTimer)

            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                isWaiting = <span class="hljs-literal">false</span>
            }, delay)
        }
    }

    <span class="hljs-keyword">return</span> work
}</code></pre><figcaption>Throttle with final event capture</figcaption></figure><h2 id="the-end">The End</h2>
<p>Putting it all together.</p>
<figure><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">
    fn,
    delay,
    { keepFinal = false, skipFirst = false } = {}
</span>) </span>{
    <span class="hljs-keyword">let</span> isWaiting = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> isFirst = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">let</span> finalTimer

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">if</span> (isFirst) {
            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                isFirst = <span class="hljs-literal">false</span>
            }, delay)
        }

        <span class="hljs-keyword">if</span> (isWaiting &amp;&amp; keepFinal) {
            clearTimeout(finalTimer)
            finalTimer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                work.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            }, delay)
        }

        <span class="hljs-keyword">if</span> (!isWaiting &amp;&amp; !(isFirst &amp;&amp; skipFirst)) {
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
            isWaiting = <span class="hljs-literal">true</span>

            clearTimeout(finalTimer)

            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                isWaiting = <span class="hljs-literal">false</span>
            }, delay)
        }
    }

    <span class="hljs-keyword">return</span> work
}</code></pre><figcaption>Throttle with extra features</figcaption></figure><figure><iframe src="https://codepen.io/zhirzh/embed/mddQzyR?default-tab=js,result" title="Timing Controls - Throttle"></iframe><figcaption>Timing Controls - Throttle</figcaption></figure></main><footer class="footer_8"><a href="/20170213-rename-a-function" class="relatedPosts_9 prevPost_11">⟵ Rename a function</a><a href="/20170122-timing-controls-1-debounce" class="relatedPosts_9 nextPost_10">Timing Controls 1 - Debounce ⟶</a></footer></body></html>